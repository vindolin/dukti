final eventAsyncValue = ref.watch(bonsoir_service.eventsProvider);


child: eventAsyncValue.when(
  data: (events) => ListView.builder(
    itemCount: events.length,
    itemBuilder: (context, index) {
      final event = events[index];
      final name = event.service?.toJson()['service.name'];
      final address = event.service?.toJson()['service.host'];
      return ListTile(
        title: Text('Name: $name'),
        subtitle: Text('Address: $address'),
      );
    },
  ),
  loading: () => const CircularProgressIndicator(),
  error: (err, stack) => Text('Error: $err'),
),



var server = Server();

/// Stream provider for the socket events
@riverpod
Stream<SocketEvent> socketEvents(Ref ref) async* {
  final duktiServicePort = await ref.watch(duktiServicePortProvider.future);

  /// Controller for the socket events
  final socketEventController = StateProvider<StreamController<SocketEvent>>((ref) {
    return StreamController<SocketEvent>.broadcast();
  });

  // Handle events on the '/clipboard' namespace
  server.of('/clipboard').on('connection', (client) {
    logger.i('Connection on /clipboard');

    client.on('clipboard', (data) {
      logger.i('Data from /clipboard => $data');
      client.emit('fromServer', 'ok');

      // Yield the event
      final event = SocketEvent(
        namespace: '/clipboard',
        eventName: 'clipboard',
        data: data,
        type: SocketDataType.clipboard,
      );
      ref.read(socketEventController).add(event);
    });
  });

  server.of('/upload').on('connection', (client) {
    logger.i('Connection on /upload');

    client.on('upload', (data) {
      logger.i('Data from /upload => $data');
      client.emit('fromServer', 'ok');

      // Yield the event
      final event = SocketEvent(
        namespace: '/upload',
        eventName: 'upload',
        data: data,
        type: SocketDataType.upload,
      );
      ref.read(socketEventController).add(event);
    });
  });

  // Handle events on the default namespace
  server.on('connection', (client) {
    logger.i('Connection on default namespace');

    client.on('event', (data) {
      logger.i('Data from default namespace => $data');
      client.emit('fromServer', 'ok');

      // Yield the event
      final event = SocketEvent(
        namespace: '/',
        eventName: 'event',
        data: data,
        type: SocketDataType.none,
      );
      ref.read(socketEventController).add(event);
    });
  });

  // Start the server
  server.listen(duktiServicePort);

  // Stream controller to emit socket events
  final controller = StreamController<SocketEvent>();

  // Expose the controller to be used in callbacks
  ref.read(socketEventController.notifier).state = controller;

  // Dispose resources when the provider is destroyed
  ref.onDispose(() {
    server.close();
    controller.close();
  });

  yield* controller.stream;
}


class AppLifecycleManager extends StatefulWidget {
  final Widget child;

  const AppLifecycleManager({super.key, required this.child});

  @override
  AppLifecycleManagerState createState() => AppLifecycleManagerState();
}

class AppLifecycleManagerState extends State<AppLifecycleManager> with WidgetsBindingObserver {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    // Perform cleanup here
    // For example, stop servers, close streams, etc.
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.detached) {
      logger.t('AppLifecycleState.detached $state');
      // The app is exiting
      // Perform cleanup if needed
    }
  }

  @override
  Widget build(BuildContext context) {
    return widget.child;
  }
}
